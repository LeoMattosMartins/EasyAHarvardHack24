"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNetwork = exports.CLINetworkAdapter = void 0;
const common_1 = require("@stacks/common");
const bitcoin = __importStar(require("bitcoinjs-lib"));
const blockstack_1 = __importDefault(require("blockstack"));
const network_1 = require("blockstack/lib/network");
class CLINetworkAdapter {
    constructor(network, opts) {
        const optsDefault = {
            consensusHash: null,
            feeRate: null,
            namespaceBurnAddress: null,
            priceToPay: null,
            priceUnits: null,
            receiveFeesPeriod: null,
            gracePeriod: null,
            altAPIUrl: opts.nodeAPIUrl,
            altTransactionBroadcasterUrl: network.broadcastServiceUrl,
            nodeAPIUrl: opts.nodeAPIUrl,
        };
        opts = Object.assign({}, optsDefault, opts);
        this.legacyNetwork = new network_1.BlockstackNetwork(opts.nodeAPIUrl, opts.altTransactionBroadcasterUrl, network.btc, network.layer1);
        this.consensusHash = opts.consensusHash;
        this.feeRate = opts.feeRate;
        this.namespaceBurnAddress = opts.namespaceBurnAddress;
        this.priceToPay = opts.priceToPay;
        this.priceUnits = opts.priceUnits;
        this.receiveFeesPeriod = opts.receiveFeesPeriod;
        this.gracePeriod = opts.gracePeriod;
        this.nodeAPIUrl = opts.nodeAPIUrl;
        this.optAlwaysCoerceAddress = false;
    }
    isMainnet() {
        return this.legacyNetwork.layer1.pubKeyHash === bitcoin.networks.bitcoin.pubKeyHash;
    }
    isTestnet() {
        return this.legacyNetwork.layer1.pubKeyHash === bitcoin.networks.testnet.pubKeyHash;
    }
    setCoerceMainnetAddress(value) {
        this.optAlwaysCoerceAddress = value;
    }
    coerceMainnetAddress(address) {
        const addressInfo = bitcoin.address.fromBase58Check(address);
        const addressHash = addressInfo.hash;
        const addressVersion = addressInfo.version;
        let newVersion = 0;
        if (addressVersion === this.legacyNetwork.layer1.pubKeyHash) {
            newVersion = 0;
        }
        else if (addressVersion === this.legacyNetwork.layer1.scriptHash) {
            newVersion = 5;
        }
        return bitcoin.address.toBase58Check(addressHash, newVersion);
    }
    getFeeRate() {
        if (this.feeRate) {
            return Promise.resolve(this.feeRate);
        }
        return this.legacyNetwork.getFeeRate();
    }
    getConsensusHash() {
        if (this.consensusHash) {
            return new Promise((resolve) => resolve(this.consensusHash));
        }
        return this.legacyNetwork.getConsensusHash().then((c) => c);
    }
    getGracePeriod() {
        if (this.gracePeriod) {
            return new Promise((resolve) => resolve(this.gracePeriod));
        }
        return this.legacyNetwork.getGracePeriod().then((g) => g);
    }
    getNamePrice(name) {
        if (this.priceUnits && this.priceToPay) {
            return new Promise((resolve) => resolve({
                units: String(this.priceUnits),
                amount: BigInt(this.priceToPay || 0),
            }));
        }
        return this.legacyNetwork.getNamePrice(name).then((priceInfo) => {
            if (!priceInfo.units) {
                priceInfo = {
                    units: 'BTC',
                    amount: BigInt(priceInfo.amount),
                };
            }
            return priceInfo;
        });
    }
    getNamespacePrice(namespaceID) {
        if (this.priceUnits && this.priceToPay) {
            return new Promise((resolve) => resolve({
                units: String(this.priceUnits),
                amount: BigInt(this.priceToPay || 0),
            }));
        }
        return super.getNamespacePrice(namespaceID).then((priceInfo) => {
            if (!priceInfo.units) {
                priceInfo = {
                    units: 'BTC',
                    amount: BigInt(priceInfo.amount),
                };
            }
            return priceInfo;
        });
    }
    getNamespaceBurnAddress(namespace, useCLI = true, receiveFeesPeriod = -1, fetchFn = (0, common_1.createFetchFn)()) {
        if (this.namespaceBurnAddress && useCLI) {
            return new Promise((resolve) => resolve(this.namespaceBurnAddress));
        }
        return Promise.all([
            fetchFn(`${this.legacyNetwork.blockstackAPIUrl}/v1/namespaces/${namespace}`),
            this.legacyNetwork.getBlockHeight(),
        ])
            .then(([resp, blockHeight]) => {
            if (resp.status === 404) {
                throw new Error(`No such namespace '${namespace}'`);
            }
            else if (resp.status !== 200) {
                throw new Error(`Bad response status: ${resp.status}`);
            }
            else {
                return Promise.all([resp.json(), blockHeight]);
            }
        })
            .then(([namespaceInfo, blockHeight]) => {
            let address = '1111111111111111111114oLvT2';
            if (namespaceInfo.version === 2) {
                if (receiveFeesPeriod < 0) {
                    receiveFeesPeriod = this.receiveFeesPeriod;
                }
                if (namespaceInfo.reveal_block + receiveFeesPeriod > blockHeight) {
                    address = namespaceInfo.address;
                }
            }
            return address;
        })
            .then((address) => this.legacyNetwork.coerceAddress(address));
    }
    getNameInfo(name) {
        return this.legacyNetwork.getNameInfo(name).then((ni) => {
            const nameInfo = {
                address: this.optAlwaysCoerceAddress ? this.coerceMainnetAddress(ni.address) : ni.address,
                blockchain: ni.blockchain,
                did: ni.did,
                expire_block: ni.expire_block,
                grace_period: ni.grace_period,
                last_txid: ni.last_txid,
                renewal_deadline: ni.renewal_deadline,
                resolver: ni.resolver,
                status: ni.status,
                zonefile: ni.zonefile,
                zonefile_hash: ni.zonefile_hash,
            };
            return nameInfo;
        });
    }
    getBlockchainNameRecord(name, fetchFn = (0, common_1.createFetchFn)()) {
        const url = `${this.legacyNetwork.blockstackAPIUrl}/v1/blockchains/bitcoin/names/${name}`;
        return fetchFn(url)
            .then(resp => {
            if (resp.status !== 200) {
                throw new Error(`Bad response status: ${resp.status}`);
            }
            else {
                return resp.json();
            }
        })
            .then(nameInfo => {
            const fixedAddresses = {};
            for (const addrAttr of ['address', 'importer_address', 'recipient_address']) {
                if (nameInfo.hasOwnProperty(addrAttr) && nameInfo[addrAttr]) {
                    fixedAddresses[addrAttr] = this.legacyNetwork.coerceAddress(nameInfo[addrAttr]);
                }
            }
            return Object.assign(nameInfo, fixedAddresses);
        });
    }
    getNameHistory(name, page, fetchFn = (0, common_1.createFetchFn)()) {
        const url = `${this.legacyNetwork.blockstackAPIUrl}/v1/names/${name}/history?page=${page}`;
        return fetchFn(url)
            .then(resp => {
            if (resp.status !== 200) {
                throw new Error(`Bad response status: ${resp.status}`);
            }
            return resp.json();
        })
            .then(historyInfo => {
            const fixedHistory = {};
            for (const historyBlock of Object.keys(historyInfo)) {
                const fixedHistoryList = [];
                for (const historyEntry of historyInfo[historyBlock]) {
                    const fixedAddresses = {};
                    let fixedHistoryEntry = {};
                    for (const addrAttr of ['address', 'importer_address', 'recipient_address']) {
                        if (historyEntry.hasOwnProperty(addrAttr) && historyEntry[addrAttr]) {
                            fixedAddresses[addrAttr] = this.legacyNetwork.coerceAddress(historyEntry[addrAttr]);
                        }
                    }
                    fixedHistoryEntry = Object.assign(historyEntry, fixedAddresses);
                    fixedHistoryList.push(fixedHistoryEntry);
                }
                fixedHistory[historyBlock] = fixedHistoryList;
            }
            return fixedHistory;
        });
    }
    coerceAddress(address) {
        return this.legacyNetwork.coerceAddress(address);
    }
    getAccountHistoryPage(address, page) {
        return this.legacyNetwork.getAccountHistoryPage(address, page);
    }
    broadcastTransaction(tx) {
        return this.legacyNetwork.broadcastTransaction(tx);
    }
    broadcastZoneFile(zonefile, txid) {
        return this.legacyNetwork.broadcastZoneFile(zonefile, txid);
    }
    getNamesOwned(address) {
        return this.legacyNetwork.getNamesOwned(address);
    }
}
exports.CLINetworkAdapter = CLINetworkAdapter;
function getNetwork(configData, testNet) {
    if (testNet) {
        const network = new blockstack_1.default.network.LocalRegtest(configData.blockstackAPIUrl, configData.broadcastServiceUrl, new blockstack_1.default.network.BitcoindAPI(configData.utxoServiceUrl, {
            username: configData.bitcoindUsername || 'blockstack',
            password: configData.bitcoindPassword || 'blockstacksystem',
        }));
        return network;
    }
    else {
        const network = new network_1.BlockstackNetwork(configData.blockstackAPIUrl, configData.broadcastServiceUrl, new blockstack_1.default.network.BlockchainInfoApi(configData.utxoServiceUrl));
        return network;
    }
}
exports.getNetwork = getNetwork;
//# sourceMappingURL=network.js.map